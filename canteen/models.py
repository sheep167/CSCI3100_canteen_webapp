# Although we are using NoSQL,
# this file is used for validating data entry or packing them as json object.
# Type ObjectId is the _id generated by MongoDB automatically on every insert operation

from typing import List, Union
from bson import ObjectId
import datetime
from canteen import login_manager, db
from flask_login import UserMixin


class bcrypt_password(str):
    pass


class Users:
    def __init__(self, email, password, username, at_canteen=None ,auth_type=2, confirmed=0, balance=0):
        self.email = str(email)
        self.password: bcrypt_password = password  # This should be a bcrypt-encrypted password
        self.username = str(username)
        self.auth_type = int(auth_type)  # 0: administrator, 1: canteen owner, 2: student
        self.confirmed = int(confirmed)
        self.balance = float(balance)  # amount of money
        self.cart = {}
        self.image_path = None
        self.staff_of = str(at_canteen)

    def to_json(self):
        # This function turns all attributes value to dict (json) for MongoDB
        return self.__dict__

    @staticmethod
    def template_object():
        return {
            'email': 'str',
            'password': 'str',
            'username': 'str',
            'auth_type': 'int',
            'confirmed': 'int',
            'balance': 'float'
        }


@login_manager.user_loader
def load_user(user_id):
    user_json = db.users.find_one({'_id': ObjectId(user_id)})
    return LoginUsers(user_json)


class LoginUsers(UserMixin, Users):
    def __init__(self, user_json):
        if( user_json ):
            super(LoginUsers, self).__init__(email=user_json.get('email'), username=user_json.get('username'), password=user_json.get('password'))
            for key, value in user_json.items():
                setattr(self, key, value)

    # Overriding get_id is required if you don't have the id property
    # Check the source code for UserMixin for details
    def get_id(self):
        object_id = self._id
        return str(object_id)


class Canteens:
    def __init__(self, name, longitude, latitude, open_at, close_at, capacity):
        self.name = str(name)
        self.longitude = str(longitude)
        self.latitude = str(latitude)
        self.open_at = str(open_at)
        self.close_at = str(close_at)
        self.capacity = int(capacity)
        self.menu = []  # List of ObjectId of Dishes are stored in here
        self.image_path = None # menu should be deprecated, use active_set instead
        self.active_set = None #ObjectId of active_set

    def to_json(self):
        return self.__dict__

    @staticmethod
    def template_object():
        return {
            'name': 'str',
            'longitude': 'str',
            'latitude': 'str',
            'open_at': 'str',
            'close_at': 'str',
            'capacity': 'int'
        }


class Dishes:
    def __init__(self, name, at_canteen, price, ingredients, type):
        self.name = str(name)
        self.at_canteen = at_canteen  # ObjectId
        self.price = float(price)
        self.in_type = None # typeId
        self.ingredients = ingredients  # List of str
        self.image_path = None

    def to_json(self):
        return self.__dict__

    @staticmethod
    def template_object():
        return {
            'name': 'str',
            'price': 'float',
            'ingredients': 'List[str]'
        }


class Orders:
    def __init__(self, created_time, created_by_user, created_at_canteen, food, total_price):
        self.at_time = created_time  # datetime.datetime object
        self.by_user = created_by_user  # ObjectId
        self.at_canteen = created_at_canteen  # ObjectId
        self.dishes = food  # List of ObjectId
        self.total_price = total_price  # float
        self.order_status = 'waiting'  # just arrive, normal, rush, finished

    def to_json(self):
        return self.__dict__

    @staticmethod
    def template_object():
        return {
            'at_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'username': 'str',
            'order_status': 'waiting, fulfilled, unfulfilled',
        }


class Comments:
    def __init__(self, posted_time, posted_by_user, posted_at_canteen, rating, paragraph):
        self.at_time = posted_time  # datetime.datetime object
        self.by_user = posted_by_user  # ObjectId
        self.at_canteen = posted_at_canteen  # ObjectId
        self.rating = rating
        self.paragraph = paragraph

    def to_json(self):
        return self.__dict__

    @staticmethod
    def template_object():
        return {
            'at_time': datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            'username': 'str',
            'rating': 'int',
            'paragraph': 'str',
        }


class Set:
    def __init__(self, name, at_canteen):
        self.name = str(name)
        self.at_canteen = at_canteen  # ObjectId
        self.types = {}  # List of dish

    def to_json(self):
        return self.__dict__

    def name_set(self, name):
        self.name = str(name)
        return str(self.name)

class Type:
    def __init__(self, name, at_canteen):
        self.name = str(name)
        self.at_canteen = at_canteen  # ObjectId
        self.dishes = []  # List of dish

    def to_json(self):
        return self.__dict__

    def name_set(self, name):
        self.name = str(name)
        return str(self.name)
    
    def add_dish(self, dish):
        self.dishes.append(dish)
        return self.dishes[len(self.dishes) - 1] # last element